#cython: boundscheck=False
#cython: wraparound=False
#cython: cdivision=False
"""
State Space Models

Author: Chad Fulton  
License: Simplified-BSD
"""

{{py:

TYPES = {
    "s": ("np.float32_t", "np.float32", "np.NPY_FLOAT32"),
    "d": ("np.float64_t", "float", "np.NPY_FLOAT64"),
    "c": ("np.complex64_t", "np.complex64", "np.NPY_COMPLEX64"),
    "z": ("np.complex128_t", "complex", "np.NPY_COMPLEX128"),
}

}}

# Typical imports
cimport numpy as np
from dismalpy.src.math cimport *
cimport dismalpy.src.blas as blas

from dismalpy.ssm._kalman_smoother cimport (
    SMOOTHER_STATE, SMOOTHER_STATE_COV, SMOOTHER_DISTURBANCE,
    SMOOTHER_DISTURBANCE_COV
)

{{for prefix, types in TYPES.items()}}
{{py:cython_type, dtype, typenum = types}}
{{py:
combined_prefix = prefix
combined_cython_type = cython_type
if prefix == 'c':
    combined_prefix = 'z'
    combined_cython_type = 'np.complex128_t'
if prefix == 's':
    combined_prefix = 'd'
    combined_cython_type = 'np.float64_t'
}}

# ### Univariate Kalman smoother
#
# The following are the routines as defined in the univariate Kalman filter.
# 
# The only modification to the conventional Kalman smoother is the recursive
# definition of the scaled smoothing error and the scaled smoothing error
# covariance matrix.
#
# See Durbin and Koopman (2012) Chapter 6.4

cdef int {{prefix}}smoothed_estimators_univariate({{prefix}}KalmanSmoother smoother):
    cdef:
        int i, j, inc = 1
        {{cython_type}} alpha = 1.0
        {{cython_type}} beta = 0.0
        {{cython_type}} gamma = -1.0
        {{cython_type}} scalar

    # Smoothing error  
    # (not used in the univariate approach)  

    # Given r_{t,0}:
    # calculate r_{t-1,p}, ..., r_{t-1, 0} and N_{t-1,p}, ..., N_{t-1,0}

    # r_{t-1,p} = T_{t-1}' r_{t,0}
    blas.{{prefix}}gemv("T", &smoother.k_states, &smoother.k_states,
                             &alpha, smoother._transition, &smoother.k_states,
                                     smoother._input_scaled_smoothed_estimator, &inc,
                             &beta, smoother._scaled_smoothed_estimator, &inc)
    # N_{t-1,p} = T_{t-1}' N_{t,0} T_{t-1}
    blas.{{prefix}}copy(&smoother.k_states2, smoother._input_scaled_smoothed_estimator_cov, &inc,
                                             smoother._scaled_smoothed_estimator_cov, &inc)
    blas.{{prefix}}gemm("T", "N", &smoother.k_states, &smoother.k_states, &smoother.k_states,
                                  &alpha, smoother._transition, &smoother.k_states,
                                          smoother._input_scaled_smoothed_estimator_cov, &smoother.k_states,
                                  &beta, smoother._tmp0, &smoother.k_states)
    blas.{{prefix}}gemm("N", "N", &smoother.k_states, &smoother.k_states, &smoother.k_states,
                                  &alpha, smoother._tmp0, &smoother.k_states,
                                          smoother._transition, &smoother.k_states,
                                  &beta, smoother._scaled_smoothed_estimator_cov, &smoother.k_states)

    # Iterate
    for i in range(smoother.k_endog-1,-1,-1):
        # $L_{t,i} = (I_m - K_{t,i} Z_{t,i})$  
        # $(m \times m) = (m \times m) - (m \times 1) (1 \times m)$
        blas.{{prefix}}gemm("N", "N", &smoother.k_states, &smoother.k_states, &inc,
                  &gamma, &smoother._kalman_gain[i*smoother.k_states], &smoother.k_states,
                          &smoother._design[i], &smoother.k_endog,
                  &beta, smoother._tmpL, &smoother.k_states)
        for j in range(smoother.k_states):
            smoother._tmpL[j + j*smoother.k_states] = smoother._tmpL[j + j*smoother.k_states] + 1

        # Scaled smoothed estimator  
        # $r_{t,i-1} = Z_{t,i}' v_{t,i} / F_{t,i} + L_{t,i}' r_{t,i}$  
        # $(m \times 1) = (m \times 1) (1 \times 1) + (m \times m) (m \times 1)$
        # Note: save $r_{t-1}$ as scaled_smoothed_estimator[t] rather than
        # as scaled_smoothed_estimator[t-1] because we actually need to store
        # T+1 of them (r_{T-1} to r_{-1} -> r_T to r_0)
        blas.{{prefix}}gemv("T", &smoother.k_states, &smoother.k_states,
                  &alpha, smoother._tmpL, &smoother.k_states,
                          smoother._scaled_smoothed_estimator, &inc,
                  &beta, smoother._tmp0, &inc)
        blas.{{prefix}}swap(&smoother.k_states, smoother._tmp0, &inc,
                                                smoother._scaled_smoothed_estimator, &inc)
        blas.{{prefix}}axpy(&smoother.k_states, &smoother._tmp2[i], &smoother._design[i], &smoother.k_endog,
                                                                    smoother._scaled_smoothed_estimator, &inc)

        # If we want smoothed disturbances, then we need to calculate
        # and store K_{t,i}' r_{t,i} for later (otherwise r_{t,i} will not be
        # available)
        if smoother.smoother_output & SMOOTHER_DISTURBANCE:
            # Note: zdot and cdot are broken, so have to use gemv for those
            {{if combined_prefix == 'd'}}
            smoother._smoothed_measurement_disturbance[i] = (
                blas.{{prefix}}dot(&smoother.k_states, &smoother._kalman_gain[i*smoother.k_states], &smoother.k_states,
                                                       smoother._scaled_smoothed_estimator, &inc)
            )
            {{else}}
            blas.{{prefix}}gemv("N", &inc, &smoother.k_states,
                           &alpha, smoother._scaled_smoothed_estimator, &inc,
                                   &smoother._kalman_gain[i*smoother.k_states], &smoother.k_states,
                           &beta, &smoother._smoothed_measurement_disturbance[i], &inc)
            {{endif}}

        # Scaled smoothed estimator covariance matrix  
        # $N_{t,i-1} = Z_{t,i}' Z_{t,i} / F_{t,i} + L_{t,i}' N_{t,i} L_{t,i}$  
        # $(m \times m) = (m \times p) (p \times m) + (m \times m) (m \times m) (m \times m)$  
        # Note: save $N_{t-1}$ as scaled_smoothed_estimator_cov[t] rather
        # than as scaled_smoothed_estimator_cov[t-1] because we actually
        # need to store T+1 of them (N_{T-1} to N_{-1} -> N_T to N_0)
        blas.{{prefix}}gemm("N", "N", &smoother.k_states, &smoother.k_states, &smoother.k_states,
                  &alpha, smoother._scaled_smoothed_estimator_cov, &smoother.k_states,
                          smoother._tmpL, &smoother.k_states,
                  &beta, smoother._tmp0, &smoother.k_states)
        blas.{{prefix}}gemm("T", "N", &smoother.k_states, &smoother.k_states, &smoother.k_states,
                  &alpha, smoother._tmpL, &smoother.k_states,
                          smoother._tmp0, &smoother.k_states,
                  &beta, smoother._scaled_smoothed_estimator_cov, &smoother.k_states)
        blas.{{prefix}}gemm("T", "N", &smoother.k_states, &smoother.k_states, &inc,
                  &alpha, &smoother._design[i], &smoother.k_endog,
                          &smoother._tmp3[i], &smoother.k_endog,
                  &alpha, smoother._scaled_smoothed_estimator_cov, &smoother.k_states)

        # If we want smoothed disturbances, then we need to calculate
        # and store K_{t,i}' N_{t,i} K_{t,i} for later (otherwise N_{t,i} will not be
        # available)
        if smoother.smoother_output & SMOOTHER_DISTURBANCE_COV:
            blas.{{prefix}}gemv("N", &smoother.k_states, &smoother.k_states,
                                     &alpha, smoother._scaled_smoothed_estimator_cov, &smoother.k_states,
                                             &smoother._kalman_gain[i*smoother.k_states], &smoother.k_states,
                                     &beta, smoother._tmpL, &smoother.k_states)
            # Note: zdot and cdot are broken, so have to use gemv for those
            {{if combined_prefix == 'd'}}
            smoother._smoothed_measurement_disturbance_cov[i*smoother.k_endog + i] = (
                blas.{{prefix}}dot(&smoother.k_states, &smoother._kalman_gain[i*smoother.k_states], &smoother.k_states,
                                                      smoother._tmpL, &inc)
            )
            {{else}}
            blas.{{prefix}}gemv("N", &inc, &smoother.k_states,
                           &alpha, smoother._tmpL, &inc,
                                   &smoother._kalman_gain[i*smoother.k_states], &smoother.k_states,
                           &beta, &smoother._smoothed_measurement_disturbance_cov[i*smoother.k_endog + i], &inc)
            {{endif}}

cdef int {{prefix}}smoothed_disturbances_univariate({{prefix}}KalmanSmoother smoother):
    # Note: this only differs from the conventional version in the
    # definition of the smoothed measurement disturbance and cov
    cdef int i, j
    cdef:
        int inc = 1
        {{cython_type}} alpha = 1.0
        {{cython_type}} beta = 0.0
        {{cython_type}} gamma = -1.0

    # Temporary arrays

    # $\\#_0 = R_t Q_t$  
    # $(m \times r) = (m \times r) (r \times r)$
    blas.{{prefix}}gemm("N", "N", &smoother.k_states, &smoother.k_posdef, &smoother.k_posdef,
              &alpha, smoother._selection, &smoother.k_states,
                      smoother._state_cov, &smoother.k_posdef,
              &beta, smoother._tmp0, &smoother.k_states)

    if smoother.smoother_output & SMOOTHER_DISTURBANCE:
        for i in range(smoother.k_endog):
            # Smoothed measurement disturbance  
            # $\hat \varepsilon_t = (H_{t,i} / F_{t,i}) (v_{t,i} - K_{t,i}' r_{t,i})$  
            # Note: K_{t,i}' r_{t,i} was stored in _smoothed_measurement_disturbance[i]
            # in smoothed_estimators_univariate, above, so we just need to implement
            # $\hat \varepsilon_t = (H_{t,i} / F_{t,i}) (v_{t,i} - \\#)$ here
            # (this is because we do not otherwise store the r_{t,i} values)  
            # $(p \times 1) = (p \times p) (p \times 1)$  
            smoother._smoothed_measurement_disturbance[i] = (
                smoother._tmp4[i] * (smoother.kfilter.forecast[i, smoother.t] - smoother._smoothed_measurement_disturbance[i])
            )

        # Smoothed state disturbance  
        # $\hat \eta_t = \\#_0' r_t$  
        # $(r \times 1) = (r \times m) (m \times 1)$  
        blas.{{prefix}}gemv("T", &smoother.k_states, &smoother.k_posdef,
                      &alpha, smoother._tmp0, &smoother.k_states,
                              smoother._input_scaled_smoothed_estimator, &inc,
                      &beta, smoother._smoothed_state_disturbance, &inc)

    if smoother.smoother_output & SMOOTHER_DISTURBANCE_COV:
        for i in range(smoother.k_endog):
            # Smoothed measurement disturbance covariance matrix  
            # $Var(\varepsilon_{t,i} | Y_n) = (H_{t,i} / F_{t,i})^2 * (F_{t,i} + K_{t,i}' N_{t,i} K_{t,i})$  
            # Note: K_{t,i}' N_{t,i} K_{t,i} was stored in _smoothed_measurement_disturbance_cov[i,i]
            # in smoothed_estimators_univariate, above, so we just need to implement
            # $Var(\varepsilon_{t,i} | Y_n) = (H_{t,i} / F_{t,i})^2 * (F_{t,i} + \\#)$ here
            # (this is because we do not otherwise store the N_{t,i} values)  
            # $(1 \times 1) = (p \times p) - (p \times p) (p \times p) - (p \times m) (m \times m) (m \times p)$  
            smoother._smoothed_measurement_disturbance_cov[i*smoother.k_endog + i] = (
                (smoother._tmp4[i]**2) * (
                    smoother.kfilter.forecast_error_cov[i, i, smoother.t] +
                    smoother._smoothed_measurement_disturbance_cov[i*smoother.k_endog + i]
                )
            )
        
        # Smoothed state disturbance covariance matrix  
        # $Var(\eta_t | Y_n) = Q_t - \\#_0' N_t \\#_0$  
        # $(r \times r) = (r \times r) - (r \times m) (m \times m) (m \times r)$  
        blas.{{prefix}}gemm("N", "N", &smoother.k_states, &smoother.k_posdef, &smoother.k_states,
                  &alpha, smoother._input_scaled_smoothed_estimator_cov, &smoother.k_states,
                          smoother._tmp0, &smoother.k_states,
                  &beta, smoother._tmpL, &smoother.k_states)
        blas.{{prefix}}copy(&smoother.k_posdef2, smoother._state_cov, &inc, smoother._smoothed_state_disturbance_cov, &inc)
        blas.{{prefix}}gemm("T", "N", &smoother.k_posdef, &smoother.k_posdef, &smoother.k_states,
                  &gamma, smoother._tmp0, &smoother.k_states,
                          smoother._tmpL, &smoother.k_states,
                  &alpha, smoother._smoothed_state_disturbance_cov, &smoother.k_posdef)

{{endfor}}